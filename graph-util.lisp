;;;; -*- Graph-util framework -*-
;;; @author: Conrad Barsli, M. D.
;;; @book: Land of Lisp: Learn to program in Lisp, one game at a time!
;;; @date: 2011
;;; @prerequisite: Graphvitz
;;;; -*- Copyright C 2011 by Conrad Barski, M.D. -*-

(defparameter *wizard-nodes* '((living-room (you are in the living-room.
                                             a wizard is snoring loudly on the couch.))
                               (garden (you are in a beautiful garden.
                                        there is a well in front of you.))
                               (attic (you are in the attic.
                                       there is a giant welding torch in the corner.)))
  "A datastruct for the nodes of the game world with a little description. It is a list as dictionary with the nodes of the world as Key and with alist (holding a description of the node) as element.")

(defparameter *wizard-edges* '((living-room (garden west door)  
                                (attic upstairs ladder))
                               (garden (living-room east door))
                               (attic (living-room downstairs ladder)))
  "A datastruct of the edges between the nodes of the world with the path for that connections. It is a list as dictionary with the node of the world where the key is the node and the element it is a list with three elements: (1) the connected node; (2) a path connector; and (3) entrance for the node connector.")

(defun dot-name (exp)
  "Function to normalize the node identifier. In other words, to make sure the used node identifier is legal, any forbidden characters is changed for a underscore.

  Args:
    exp (string): a expression to represent a identifier of a DOT file.

  Return:
    (string): A legal node identifier, in accord with DOT format."
  (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))

(defparameter *max-label-length* 30
  "A value to determine the maximum number of characters for a label.")

(defun dot-label (exp)
  "Generate the label that should appear in the node when it is drawn.

  Args:
    exp (string): a DOT label.

  Return:
    (string): the label of the drawn node. The label will consist of the node name and the data linked to the node in the node alist."
  (if exp
      (let ((s (write-to-string exp :pretty nil)))
        (if (> (length s) *max-label-length*)
            (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
            s))
      ""))

(defun nodes->dot (nodes)
  "Generate the DOT information for nodes.

  Args:
    nodes (alist): an alist with a node key and yours rescptivily description.

  Return:
    (string): a string with the command to generates the DOT information for nodes wich encodes them."
  (mapc (lambda (node)
          (fresh-line)
          (princ (dot-name (car node)))
          (princ "[label=\"")
          (princ (dot-label node))
          (princ "\"];"))
        nodes))

(defun edges->dot (edges)
  "Generate a DOT information for edges.

  Args:
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (string): a string with the command to generate the DOT information fo edges wich encodes them."
  (mapc (lambda (node)
          (mapc (lambda (edge)
                  (fresh-line)
                  (princ (dot-name (car node)))
                  (princ "->")
                  (princ (dot-name (car edge)))
                  (princ "[label=\"")
                  (princ (dot-label (cdr edge)))
                  (princ "\"];"))
                (cdr node)))
        edges))

(defun graph->dot (nodes edges)
  "Generate all the DOT data.

  Args:
    nodes (alist): an alist with a node key and yours rescptivily description.
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (string): a string with the information of the graph generated by the DOT data."
  (princ "digraph{")
  (nodes->dot nodes)
  (edges->dot edges)
  (princ "}"))

(defun uedges->dot (edges)
  "Generate a DOT information for edges.

  Args:
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (string): a string with the command to generate the DOT information for the edges of a undirect-graph wich encodes them."
  (maplist (lambda (lst)
             (mapc (lambda (edge)
                     (unless (assoc (car edge) (cdr lst))
                       (fresh-line)
                       (princ (dot-name (caar lst)))
                       (princ "--")
                       (princ (dot-name (car edge)))
                       (princ "[label=\"")
                       (princ (dot-label (cdr edge)))
                       (princ "\"];")))
                   (cdar lst)))
           edges))

(defun ugraph->dot (nodes edges)
  "Generate all the DOT data.

  Args:
    nodes (alist): an alist with a node key and yours rescptivily description.
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (string): a string with the information of the undirected graph generated by the DOT data."
  (princ "graph{")
  (nodes->dot nodes)
  (uedges->dot edges)
  (princ "}"))

(defun dot->png (fname thunk)
  "Uses DOT information to generate image, .png, of the graph.

  Args:
    fname (string): a path for the DOT information.
    thunk (function): a simple function to use as a subroutine for the creation of node and edges after the fname call.

  Return:
    (error) generate a PNG file of the graph generated."
  (with-open-file (*standard-output* (concatenate 'string fname ".dot") :direction :output :if-exists :supersede)
    (funcall thunk))
  (ext:shell (concatenate 'string "dot -Tpng -O " fname ".dot")))

(defun dgraph->png (fname nodes edges)
  "Generate a PNG file of a direct-graph.

  Args:
    fname (string): a path for the DOT file.
    nodes (alist): an alist with a node key and yours rescptivily description.
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (error) generate a PNG file of the graph generated."
  (dot->png fname
            (lambda ()
              (dgraph->dot nodes edges))))

(defun ugraph->png (fname nodes edges)
  "Generate a PNG file of a undirect-graph.

  Args:
    fname (string): a path for the DOT file.
    nodes (alist): an alist with a node key and yours rescptivily description.
    edges (alist): an alist with a node key and a list with yours nodes connections.

  Return:
    (error) generate a PNG file of the graph generated."
  (dot->png fname
            (lambda ()
              (ugraph->dot nodes edges))))

;; **************** -*- Summary -*- ****************
;; *                   Chapter 7                   *
;; *  In this chapter, we discussed exotic types   *
;; * of lists and created a drawing library for    *
;; * mathematical graphs. Along the way, you       *
;; * learned the following:                        *
;; * - You can create lists in Lisp that end in a  *
;; * value other than nil. Such lists are          *
;; * displayed with an extra dot before the last   *
;; * item and are called dotted lists.             *
;; * - Pairs are what you get when you cons        *
;; * together two items that are not lists         *
;; * themselves. They can also be thought of as    *
;; * dotted lists that contain only two items.     *
;; * - Circular lists are lists where the last     *
;; * cons cell points to an earlier cons cell in   *
;; * the same list.                                *
;; * - Association lists (alists) are lists of     *
;; * pairs. They can be used to store data that is *
;; * in the form of keys associated with values.   *
;; * - Lisp syntax expressions are great for       *
;; * storing and visualizing list-like and         *
;; * hierarchical data. Extra tools may be helpful *
;; * for visualizing more complex data.            *
;; * - If your data is in the form of a            *
;; * mathematical graph, itâ€™s helpful to be able   *
;; * to generate pictures of your data using       *
;; * Graphviz.                                     *
;; * - A common technique for generating textual   *
;; * data in a Lisp program is to write functions  *
;; * that print the text to the console for easy   *
;; * debugging and wrap these functions in thunks. *
;; * -Then you can send these thunks to other      *
;; * functions, which capture the console output   *
;; * and route the text to the appropriate         *
;; * destination, such as writing it to a file.    *
;; *************************************************
